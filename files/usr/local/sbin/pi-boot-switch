#!/bin/bash
# ----------------------------------------------------------------------------
# Raspbian boot-switcher: manage Raspberry Pi multiboot system
#
# ----------------------------------------------------------------------------
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/pi-boot-switch
# ----------------------------------------------------------------------------

# some constants   ------------------------------------------------------------

BOOT_PART="/boot"
BOOT_BACKUP="/_boot"
FS_TYPE="ext4"
REBOOT_DELAY="5"

# set defaults   --------------------------------------------------------------

setDefaults() {
  targetDevice=""
  rootDevice=""
  bootDevice=""
  verbose=""
  format=""
  isSD=""
  keepHome=""
  updateHome=""

  # operations
  info=""
  copy=""
  label=""
  newBoot=""
  switch=""
  reboot=""
  install=""
}

# --- help   -----------------------------------------------------------------

usage() {
  local pgm=`basename $0`
  echo -e "\n$pgm: manage Raspberry Pi multiboot system\n\
  \nusage: `basename $0` [options]\n\
  Possible options:\n\n\
    -I          show partition info

    -c          copy partition (select target with -t)
    -f source   source partition (default: current root-partition)
                use with -c, e.g. '-f /dev/mmcblk0p2'
    -t dest     target partition (required for -i or -c, e.g. '-t /dev/sdc')
    -S          target partition is on a SD-card, not an usb-device
    -F          format target partition
    -k          keep existing /home on target during copy (don't use -F)

    -L label    set label of target partition (also available standalone)

    -B          copy /boot to partition dest and set dest as new /boot

    -s          switch to partition dest for next boot (requires reboot)
                (select target with -t)
    -u          update /home on dest from current partition before switching
    -R          reboot immediately after switching

    -i image    install image to target partition


    -v          verbose operation
    -h          show this help
"
  exit 3
}

# --- parse arguments and set variables   ------------------------------------

parseArguments() {
  while getopts ":Icf:t:SFkL:BsuRi:vh" opt; do
    case $opt in
      I) info=1;;
      c) copy=1;;
      f) srcPart="$OPTARG";;
      t) targetDevice="$OPTARG";;
      S) isSD=1;;
      F) format=1;;
      k) keepHome=1;;
      L) label=1; targetLabel="$OPTARG";;
      B) newBoot=1;;
      s) switch=1;;
      u) updateHome=1;;
      R) reboot=1;;
      i) install=1; srcImage="$OPTARG";;
      v) verbose="-v";;
      h) usage;;
      ?) echo "error: illegal option: $OPTARG"
           usage;;
    esac
  done

  shift $((OPTIND-1))
  dirs=("$@")
}

# --- check arguments   ------------------------------------------------------

checkArguments() {
 [ -n "$targetDevice" ] && \
   [ "${targetDevice:0:4}" != "/dev" ] && targetDevice="/dev/$targetDevice"
}

# --- write message to log and stderr   --------------------------------------

msg() {
  echo -e "$1" >&2
}

# --- copy files of root-partition   -----------------------------------------

copyRoot() {
  local src="$1" dst="$2"
  msg "info: copying $src to $dst"
  rsync $verbose -a -H -A -X -S -x --delete \
                 --exclude=/tmp/\*\* \
                 --exclude=/var/tmp/\*\* \
                 ${keepHome:+"--exclude=/home"} \
                 "$src" "$dst"
}

# --- copy files of boot-partition   -----------------------------------------

copyBoot() {
  local src="$1" dst="$2"
  [ ! -d "$dst" ] && mkdir "$dst"
  msg "info: copying $src to $dst"
  rsync $verbose -a --delete --no-owner --no-group --modify-window=2 "$src" "$dst"
}

# --- restore files of boot-partition   --------------------------------------

restoreBoot() {
  local src="$1"
  [ ! -d /boot ] && mkdir /boot
  grep -qw "/boot" /etc/mtab || mount /boot
  msg "info: restoring /boot from $src"
  copyBoot "$src/" "/boot"
}

# --- update fstab after copy   ----------------------------------------------

updateFstab() {
  local part="$1" fstabPath="$2"
  msg "info: fixing /etc/fstab on $part"
  sed -i -e "/\W\/\W/s,^[^ \t]*,$part," "$fstabPath"
}

# --- update cmdline.txt after copy   ----------------------------------------

updateCmdline() {
  local part="$1" cmdlinePath="$2"
  msg "info: fixing $cmdlinePath"
  sed -i -e "s,root=[^ ]*,root=$part," "$cmdlinePath"
}

# --- get default label   ----------------------------------------------------

getLabel() {
  local ID VERSION_ID
  eval $(grep "^ID=\|^VERSION_ID=" "$1/etc/os-release")
  targetLabel="$ID $VERSION_ID"
}

# --- show partition information   -------------------------------------------

doInfo() {
  grep -qw "/boot" /etc/mtab || mount /boot
  declare -A role

  # fetch current roles of partitions
  local currentRoot=$(mount | grep -w / | cut -f1 -d" ")
  local currentBoot=$(mount | grep -w /boot | cut -f1 -d" ")
  local nextRoot=$(sed -e 's/.*root=\([^ ]*\) .*$/\1/' /boot/cmdline.txt)
  if grep -q PARTUUID <<< "$nextRoot"; then
    nextRoot=$(blkid -l -t "$nextRoot" | cut -f1 -d":")
  fi

  role[$currentRoot]="current root"
  if [ -n "${role[$nextRoot]}" ]; then
    role[$nextRoot]+=" / next root"
  else
    role[$nextRoot]="next root"
  fi
  role[$currentBoot]="current boot"

  # check all partitions and print label and role

  echo "Partition       | Label            | Role"
  echo "----------------|------------------|---------------------"

  local part label rest
  ( while read part rest; do
    if grep -qw LABEL <<< "$rest"; then
      label=$(sed -e 's/LABEL="\([^"]*\)".*/\1/' <<< "$rest")
    else
      label=""
    fi
    part="${part%:}"
    printf "%-15s | %-16s | %-s\n" "$part" "$label" "${role[$part]}"
  done < <( blkid | grep PARTUUID)
  ) | sort
}

# --- label current/target partition   ---------------------------------------

doLabel() {
  [ -z "$targetLabel" ] && return
  local device
  if [ -n "$targetDevice" ]; then
    device="$targetDevice"
  else
    device=$(mount | grep -w / | cut -d" " -f1)
  fi

  # query filesystem type
  local fstype=$(blkid | \
    sed -ne "/${device:5}/s/.*TYPE=\"\([^\"]*\).*/\1/p")

  if [ -z "$fstype" ]; then
    msg "error: $device has no filesystem"
    return
  fi

  msg "info: setting label for $device: $targetLabel"
  if [[ "${fstype,,}" =~ ext.* ]]; then
    e2label "$device" "$targetLabel"
  elif [ "${fstype,,}" = "vfat" ]; then
    if type -p fatlabel > /dev/null; then
      fatlabel "$device" "$targetLabel"
    else
      msg "warning: could not label $device - please install fatlabel"
    fi
  else
    msg "warning: could not label $device - unsupported filesystem type"
  fi
}

# --- fix /etc/fstab on all root-devices   -----------------------------------

fixAllFstab() {
  # fix current root partition
  local currentRoot=$(mount | grep -w / | cut -f1 -d" ")
  msg "info: fixing /boot in /etc/fstab on current root-partition $part"
  sed -i -e "/\W\/boot\W/s,^[^ \t]*,$bootDevice," "/etc/fstab"

  # create temporary mountpoint
  local tmpMnt=`mktemp -d --tmpdir pi-boot-switch.XXXXXX`

  # we only take partitions with label into account
  local part rest
  while read part rest; do
    part="${part%:}"
    [ "$part" = "$currentRoot" ] && continue

    msg "info: testing $part ..."
    if ! mount "$part" "$tmpMnt"; then
      msg "info: could not mount $part: ignoring"
      continue
    fi
    if [ -d "$tmpMnt/_boot" ]; then
      msg "info: found _boot, fixing /boot in /etc/fstab on partition $part"
      sed -i -e "/\W\/boot\W/s,^[^ \t]*,$bootDevice," "$tmpMnt/etc/fstab"
    else
      msg "info: $part is not a relevant partition"
    fi
    umount "$tmpMnt"
  done < <( blkid | grep "LABEL" )

  # cleamup temporary mountpoint
  mount | grep -qw "$tmpMnt" || rm -fr "$tmpMnt"
}

# --- create and configure new boot-partition   ------------------------------

doNewBoot() {
  local bootDevice="$targetDevice"
  if [ -z "$bootDevice" ]; then
    msg "error: no target boot device specified"
    exit 3
  elif [ ! -b "$bootDevice" ]; then
    msg "error: $bootDevice is no block device"
    exit 3
  fi

  # format partition
  if [ -n "$format" ]; then
    msg "info: formatting partition $bootDevice with Fat32"
    mkfs.fat $verbose -F 32 "$bootDevice"
  else
    msg "warning: not formatting $targetDevice!"
  fi

  # mount new boot partition
  local mntNewBoot=`mktemp -d --tmpdir pi-boot-switch.XXXXXX`
  msg "info: mounting $bootDevice on $mntNewBoot"
  if ! mount "$bootDevice" "$mntNewBoot"; then
    msg "error: could not mount $bootDevice, aborting!"
    rm -fr "$mntNewBoot"
    exit 3
  fi

  # mount and copy /boot
  mount | grep -qw /boot || mount /boot
  if [ $? -ne 0 ]; then
    msg "error: could not mount /boot, aborting!"
    exit 3
  fi
  copyBoot "/boot/" "$mntNewBoot"          # copy to new boot

  umount "$mntNewBoot" && rm -fr "$mntNewBoot"
  if type -p fatlabel > /dev/null; then
    fatlabel "$bootDevice" "boot"
  else
    msg "warning: could not label $bootDevice - please install fatlabel"
  fi

  # change device for mountpoint /boot in all systems
  fixAllFstab

  msg "info: activate USB-boot to and remove SD-card to boot from $bootDevice"
}

# --- install an image to a partition   --------------------------------------

doInstall() {
  msg "info: sorry, not implemented yet!"
}

# --- copy files to target partition   ---------------------------------------

doCopy() {
  if [ -z "$targetDevice" ]; then
    msg "error: no target partition selected"
    exit 3
  fi

  # add sanity check
  if mount | grep -qw "$targetDevice"; then
    msg "error: $targetDevice is mounted. Cowardly refusing to continue"
    exit 3
  fi

  # format target partition
  if [ -n "$format" ]; then
    msg "info: formatting partition $targetDevice with $FS_TYPE"
    if [ -n "$verbose" ]; then
      mkfs.$FS_TYPE -F -E "lazy_itable_init=0,lazy_journal_init=0"  "$targetDevice"
    else
      mkfs.$FS_TYPE -q -F -E "lazy_itable_init=0,lazy_journal_init=0"  "$targetDevice"
    fi
  else
    msg "warning: not formatting $targetDevice!"
  fi

  # mount target partition
  local mntDirTarget=`mktemp -d --tmpdir pi-boot-switch.XXXXXX`
  msg "info: mounting $targetDevice on $mntDirTarget"
  if ! mount "$targetDevice" "$mntDirTarget"; then
    msg "error: could not mount $targetDevice, aborting!"
    exit 3
  fi

  # copy files
  copyRoot / "$mntDirTarget"

  # fix fstab
  if [ -z "$isSD" ]; then
    updateFstab "$targetDevice" "$mntDirTarget/etc/fstab"
  else
    updateFstab "${targetDevice/sd?/mmcblk0p}" "$mntDirTarget/etc/fstab"
  fi

  # mount and copy /boot
  mount | grep -qw /boot || mount /boot
  copyBoot "/boot/" "$mntDirTarget/_boot"    # copy to new root/_boot
  
  # fix /_boot/cmdline.txt
  if [ -z "$isSD" ]; then
    updateCmdline "$targetDevice" "$mntDirTarget/_boot/cmdline.txt"
  else
    updateCmdline "${targetDevice/sd?/mmcblk0p}" "$mntDirTarget/_boot/cmdline.txt"
  fi

  # get label if empty
  if [ -z "$targetLabel" ]; then
    getLabel "$mntDirTarget"
    label=1                      # force labelling
  fi

  # umount target partitition
  umount "$mntDirTarget" && rm -fr "$mntDirTarget"

  msg "info: copied system to $targetDevice"
  if [ -z "$switch" -a -z "$switchSelect" ]; then
    msg "info: use ${0##*/} with option '-s $targetDevice' to boot from new partition"
  else
    msg "info: reboot the system to start from $targetDevice"
  fi
}

# --- switch root-partition   ------------------------------------------------

doSwitch() {
  if [ -z "$targetDevice" ]; then
    msg "error: no target partition selected"
    exit 3
  fi
  local rootDevice="$targetDevice"

  # mount /boot and update /_boot
  mount | grep -qw /boot || mount /boot
  if [ $? -ne 0 ]; then
    msg "error: could not mount /boot, aborting!"
    exit 3
  fi
  copyBoot "/boot/" "/_boot"             # backup to current root/_boot

  # check if new root is currently mounted
  if mount | grep -qw "$rootDevice"; then
    msg "error: target partition currently mounted, aborting!"
    exit 3
  fi

  # mount new-root
  local mntNewRoot=`mktemp -d --tmpdir pi-boot-switch.XXXXXX`
  msg "info: mounting $rootDevice on $mntNewRoot"
  if ! mount "$rootDevice" "$mntNewRoot"; then
    msg "error: could not mount $rootDevice, aborting!"
    exit 3
  fi

  if [ ! -d "$mntNewRoot/_boot/" ]; then
    msg "error: $rootDevice has no /_boot directory, aborting!"
    umount "$mntNewRoot" && rm -fr "$mntNewRoot"
    exit 3
  fi

  # copy /new/_boot -> /boot
  copyBoot "$mntNewRoot/_boot/" "/boot"

  # update /home if requested
  if [ "$updateHome" = "1" ]; then
    rsync $verbose -a -H -A -X -S -x /home "$mntNewRoot"
  fi

  # umount /new
  msg "info: unmounting $rootDevice"
  umount "$mntNewRoot" && rm -fr "$mntNewRoot"

  msg "info: reboot the system to start from $rootDevice"
}

# --- reboot the system   ----------------------------------------------------

doReboot() {
  msg "info: rebooting the system in $REBOOT_DELAY seconds"
  sleep "$REBOOT_DELAY"
  shutdown -r now &
}

# --- main program   ---------------------------------------------------------

setDefaults
parseArguments "$@"
checkArguments

# execute operation(s)

if [ -n "$info" ]; then
  doInfo
elif [ -n "$install" ]; then
  doInstall
else
  # preserve order of execution
  [ -n "$copy" ]       && doCopy
  [ -n "$switch" ]     && doSwitch
  [ -n "$newBoot" ]    && doNewBoot
  [ -n "$label" ]      && doLabel
  [ -n "$reboot" ]     && doReboot
fi
