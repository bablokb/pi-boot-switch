#!/bin/bash
# ----------------------------------------------------------------------------
# Raspbian boot-switcher: manage Raspberry Pi multiboot system
#
# ----------------------------------------------------------------------------
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/pi-boot-switch
# ----------------------------------------------------------------------------

# some constants   ------------------------------------------------------------

BOOT_PART="/boot"
BOOT_BACKUP="/_boot"
FS_TYPE="ext4"
REBOOT_DELAY="5"

# set defaults   --------------------------------------------------------------

setDefaults() {
  targetDevice=""
  rootDevice=""
  bootDevice=""
  verbose=""
  format=""

  # operations
  info=""
  copy=""
  label=""
  newBoot=""
  switch=""
  switchSelect=""
  reboot=""
  updateRoot=""
  updateBoot=""
  install=""
}

# --- help   -----------------------------------------------------------------

usage() {
  local pgm=`basename $0`
  echo -e "\n$pgm: manage Raspberry Pi multiboot system\n\
  \nusage: `basename $0` [options]\n\
  Possible options:\n\n\
    -I          show partition info

    -c          copy partition\n\
    -f source   source partition (default: current root-partition)\n\
                use with -c, e.g. '-f /dev/mmcblk0p2'\n\
    -t dest     target partition (required for -i or -c, e.g. '-t /dev/sdc')\n\
    -F          format target partition (recommended)\n\
    -L label    set label of target partition (also available standalone)

    -B part     copy /boot to partition part and set part as new /boot

    -s part     switch to partition part for next boot (requires reboot)\n\
    -S          switch to partition (use selection-dialog, requires reboot)\n\
    -R          reboot immediately after switching

    -u part     update target partition from current root-partition\n\
    -U          update backup of /boot on current root-partition

    -i image    install image to target partition

    -v          verbose operation\n\
    -h          show this help\n\
"
  exit 3
}

# --- parse arguments and set variables   ------------------------------------

parseArguments() {
  while getopts ":Icf:t:FL:B:s:SRu:Ui:vh" opt; do
    case $opt in
      I) info=1;;
      c) copy=1;;
      f) srcPart="$OPTARG";;
      t) targetDevice="$OPTARG";;
      F) format=1;;
      L) label=1; targetLabel="$OPTARG";;
      B) newBoot=1; bootDevice="$OPTARG";;
      s) switch=1; rootDevice="$OPTARG";;
      S) switchSelect=1;;
      R) reboot=1;;
      u) updateRoot=1; rootDevice="$OPTARG";;
      U) updateBoot=1;;
      i) install=1; srcImage="$OPTARG";;
      h) usage;;
      v) verbose="-v";;
      ?) echo "error: illegal option: $OPTARG"
           usage;;
    esac
  done

  shift $((OPTIND-1))
  dirs=("$@")
}

# --- check arguments   ------------------------------------------------------

checkArguments() {
 :
#  if [ -z "$op" ]; then
#    msg "error: no operation specified"
#    exit 3
#  fi
}

# --- write message to log and stderr   --------------------------------------

msg() {
  echo -e "$1" >&2
}

# --- copy files of root-partition   -----------------------------------------

copyRoot() {
  local src="$1" dst="$2"
  msg "copying $src to $dst"
  rsync $verbose -a -H -A -X -S -x \
                 --exclude=/tmp/\*\* \
                 --exclude=/var/tmp/\*\* "$src" "$dst"
}

# --- copy files of boot-partition   -----------------------------------------

copyBoot() {
  local src="$1" dst="$2"
  [ ! -d "$dst" ] && mkdir "$dst"
  msg "copying $src to $dst"
  # TODO: extra rsync-args for fat-partitions
  rsync $verbose -a "$src" "$dst"
}

# --- restore files of boot-partition   --------------------------------------

restoreBoot() {
  local src="$1"
  [ ! -d /boot ] && mkdir /boot
  grep -qw "/boot" /etc/mtab || mount /boot
  msg "restoring /boot from $src"
  copyBoot "$src/" "/boot"
}

# --- update fstab after copy   ----------------------------------------------

updateFstab() {
  local part="$1" fstabPath="$2"
  msg "fixing /etc/fstab on $part"
  sed -i -e "/\W\/\W/s,^[^ \t]*,$part," "$fstabPath"
}

# --- update cmdline.txt after copy   ----------------------------------------

updateCmdline() {
  local part="$1" cmdlinePath="$2"
  msg "fixing $cmdlinePath"
  sed -i -e "s,root=[^ ]*,root=$part," "$cmdlinePath"
}

# --- get default label   ----------------------------------------------------

getLabel() {
  local ID VERSION_ID
  eval $(grep "^ID=\|^VERSION_ID=" "$1/etc/os-release")
  targetLabel="$ID $VERSION_ID"
}

# --- show partition information   -------------------------------------------

doInfo() {
  grep -qw "/boot" /etc/mtab || mount /boot
  declare -A role

  # fetch current roles of partitions
  local currentRoot=$(mount | grep -w / | cut -f1 -d" ")
  local currentBoot=$(mount | grep -w /boot | cut -f1 -d" ")
  local nextRoot=$(sed -e 's/.*root=\([^ ]*\) .*$/\1/' /boot/cmdline.txt)

  role[$currentRoot]="current root"
  if [ -n "${role[$nextRoot]}" ]; then
    role[$nextRoot]+=" / next root"
  else
    role[$nextRoot]="next root"
  fi
  role[$currentBoot]="current boot"

  # check all partitions and print label and role

  echo "Partition       | Label            | Role"
  echo "----------------|------------------|---------------------"

  local part label rest
  ( while read part rest; do
    if grep -qw LABEL <<< "$rest"; then
      label=$(sed -e 's/LABEL="\([^"]*\)".*/\1/' <<< "$rest")
    else
      label=""
    fi
    part="${part%:}"
    printf "%-15s | %-16s | %-s\n" "$part" "$label" "${role[$part]}"
  done < <( blkid | grep PARTUUID)
  ) | sort
}

# --- label current/target partition   ---------------------------------------

doLabel() {
  [ -z "$targetLabel" ] && return
  if [ -n "$targetDevice" ]; then
    e2label "$targetDevice" "$targetLabel"
  else
    e2label $(mount | grep -w / | cut -d" " -f1) "$targetLabel"    
  fi
}

# --- create and configure new boot-partition   ------------------------------

doNewBoot() {
  msg "info: sorry, not implemented yet!"
}

# --- install an image to a partition   --------------------------------------

doInstall() {
  msg "info: sorry, not implemented yet!"
}

# --- update boot-partition   ------------------------------------------------

doUpdateBoot() {
  msg "info: sorry, not implemented yet!"
}

# --- update root-partition   ------------------------------------------------

doUpdateRoot() {
  msg "info: sorry, not implemented yet!"
}

# --- copy files to target partition   ---------------------------------------

doCopy() {
  if [ -z "$targetDevice" ]; then
    msg "error: no target partition selected"
    exit 3
  fi

  # format target partition
  if [ -n "$format" ]; then
    msg "info: formatting partition $targetDevice with $FS_TYPE"
    if [ -n "$verbose" ]; then
      mkfs.$FS_TYPE -F -E "lazy_itable_init=0,lazy_journal_init=0"  "$targetDevice"
    else
      mkfs.$FS_TYPE -q -F -E "lazy_itable_init=0,lazy_journal_init=0"  "$targetDevice"
    fi
  else
    msg "warning: not formatting $targetDevice!"
  fi

  # mount target partition
  local mntDirTarget=`mktemp -d --tmpdir pi-boot-switch.XXXXXX`
  msg "info: mounting $targetDevice on $mntDirTarget"
  if ! mount "$targetDevice" "$mntDirTarget"; then
    msg "error: could not mount $targetDevice, aborting!"
    exit 3
  fi

  # copy files
  copyRoot / "$mntDirTarget"

  # fix fstab
  updateFstab "$targetDevice" "$mntDirTarget/etc/fstab"

  # mount and copy /boot
  mount | grep -qw /boot || mount /boot
  copyBoot "/boot/" "$mntDirTarget/_boot"    # copy to new root/_boot
  
  # fix /_boot/cmdline.txt
  updateCmdline "$targetDevice" "$mntDirTarget/_boot/cmdline.txt"

  # get label if empty
  if [ -z "$targetLabel" ]; then
    getLabel "$mntDirTarget"
    label=1                      # force labelling
  fi

  # umount target partitition
  umount "$mntDirTarget" && rm -fr "$mntDirTarget"

  msg "info: copied system to $targetDevice"
  if [ -z "$switch" -a -z "$switchSelect" ]; then
    msg "info: use $0 with option '-s $targetDevice' to boot from new partition"
  else
    msg "info: reboot the system to start from $rootDevice"
  fi
}

# --- switch boot-partition   ------------------------------------------------

doSwitch() {
  # mount /boot and update /_boot
  mount | grep -qw /boot || mount /boot
  copyBoot "/boot/" "/_boot"             # backup to current root/_boot

  # mount new-root
  local mntNewRoot=`mktemp -d --tmpdir pi-boot-switch.XXXXXX`
  msg "info: mounting $rootDevice on $mntNewRoot"
  if ! mount "$rootDevice" "$mntNewRoot"; then
    msg "error: could not mount $rootDevice, aborting!"
    exit 3
  fi

  if [ ! -d "$mntNewRoot/_boot/" ]; then
    msg "error: $rootDevice has no /_boot directory, aborting!"
    umount "$mntNewRoot" && rm -fr "$mntNewRoot"
    exit 3
  fi

  # copy /new/_boot -> /boot
  copyBoot "$mntNewRoot/_boot/" "/boot"

  # umount /new
  msg "info: unmounting $rootDevice"
  umount "$mntNewRoot" && rm -fr "$mntNewRoot"

  msg "info: reboot the system to start from $rootDevice"
}

# --- reboot the system   ----------------------------------------------------

doReboot() {
  msg "info: rebooting the system in $REBOOT_DELAY seconds"
  sleep "$REBOOT_DELAY"
  shutdown -r &
}

# --- main program   ---------------------------------------------------------

setDefaults
parseArguments "$@"
checkArguments

# execute operation(s)

if [ -n "$info" ]; then
  doInfo
elif [ -n "$install" ]; then
  doInstall
elif [ -n "$updateRoot" ]; then
  doUpdateRoot
elif [ -n "$updateBoot" ]; then
  doUpdateBoot
else
  # preserve order of execution
  [ -n "$copy" ]                       && doCopy
  [ -n "$switch" -o n "$switchSelect"] && doSwitch
  [ -n "$newBoot" ]                    && doNewBoot
  [ -n "$label" ]                      && doLabel
  [ -n "$reboot" ]                     && doReboot
fi